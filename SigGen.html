<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音頻產生器</title>
    <!-- 載入 Tailwind CSS 框架，用於美觀和響應式設計 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 自定義 Range Slider 樣式 */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        /* 滑塊拇指 (Thumb) 樣式 */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -8px; /* 垂直居中調整 */
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        /* 滑塊軌道 (Track) 樣式 */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #cbd5e1;
            border-radius: 2px;
        }
        /* 失去焦點時移除瀏覽器預設輪廓 */
        input[type=range]:focus {
            outline: none;
        }
        
        /* 波形按鈕選中時的樣式 */
        .btn-wave.active {
            background-color: #3b82f6;
            color: white;
            border-color: #3b82f6;
            /* 強調效果 */
            box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.5), 0 2px 4px -2px rgba(59, 130, 246, 0.5);
        }
        
        /* 防止元素被選取，提升 UI 體驗 */
        .no-select {
            user-select: none;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 min-h-screen flex flex-col items-center justify-center p-4 font-sans">

    <!-- 主容器 -->
    <div class="max-w-2xl w-full bg-white rounded-2xl shadow-xl overflow-hidden border border-slate-200">
        
        <!-- 標題區塊 -->
        <div class="bg-slate-800 text-white p-6 text-center relative">
            <h1 class="text-2xl font-bold tracking-wider">音頻產生器</h1>
            <p class="text-sm text-slate-400 mt-1">頻率範圍：20 Hz (極低頻) ~ 20000 Hz (極高頻)</p>
        </div>

        <div class="p-6 md:p-8 space-y-8">

            <!-- 示波器視覺化區塊 -->
            <div class="relative w-full h-48 bg-black rounded-lg shadow-inner overflow-hidden border-2 border-slate-300">
                <canvas id="oscilloscope" class="w-full h-full"></canvas>
                <div class="absolute top-2 left-3 text-green-500 text-xs font-mono opacity-80 pointer-events-none">
                    示波器<br>
                    <span id="hz-display-canvas">440.0</span> Hz
                </div>
            </div>

            <!-- 播放/停止按鈕 -->
            <div class="flex justify-center">
                <button id="play-btn" class="no-select group relative flex items-center justify-center w-24 h-24 rounded-full bg-slate-100 border-4 border-green-500 hover:bg-green-50 transition-all duration-200 shadow-lg active:scale-95 focus:outline-none focus:ring-4 focus:ring-green-200">
                    <!-- 播放圖標 -->
                    <svg id="icon-play" class="w-10 h-10 text-green-600 ml-1" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    <!-- 停止圖標 (預設隱藏) -->
                    <svg id="icon-stop" class="w-10 h-10 text-red-500 hidden" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M6 6h12v12H6z"/>
                    </svg>
                    <span id="play-text" class="absolute -bottom-8 font-bold text-slate-600">播放</span>
                </button>
            </div>

            <!-- 控制面板格線 -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                
                <!-- 頻率控制 -->
                <div class="space-y-4 bg-slate-50 p-4 rounded-xl border border-slate-100">
                    <div class="flex justify-between items-center">
                        <label class="font-bold text-slate-700 flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"/></svg>
                            頻率 (Hz)
                        </label>
                        <!-- 頻率輸入框 -->
                        <input type="number" id="freq-input" value="440" min="20" max="20000" step="0.1" class="w-28 px-2 py-1 text-right text-lg font-mono border border-slate-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                    </div>
                    
                    <!-- 頻率滑塊 (將在 JS 中實現對數處理) -->
                    <input type="range" id="freq-slider" min="0" max="1000" value="700" step="1" class="w-full">
                    
                    <!-- 快速八度控制按鈕 -->
                    <div class="flex gap-2 justify-center pt-1">
                        <button onclick="window.adjustOctave(0.5)" class="px-3 py-1 text-xs bg-white border border-slate-300 rounded hover:bg-slate-100 transition active:bg-slate-200">÷2 (降八度)</button>
                        <button onclick="window.setFreq(440)" class="px-3 py-1 text-xs bg-white border border-slate-300 rounded hover:bg-slate-100 transition active:bg-slate-200">440 Hz (標準音)</button>
                        <button onclick="window.adjustOctave(2)" class="px-3 py-1 text-xs bg-white border border-slate-300 rounded hover:bg-slate-100 transition active:bg-slate-200">×2 (升八度)</button>
                    </div>
                </div>

                <!-- 波形控制 -->
                <div class="space-y-4 bg-slate-50 p-4 rounded-xl border border-slate-100">
                    <label class="font-bold text-slate-700 block mb-2">波形</label>
                    <div class="grid grid-cols-2 gap-2">
                        <!-- 正弦波按鈕 (預設) -->
                        <button class="btn-wave active px-3 py-2 border rounded-lg text-sm font-medium transition-colors bg-white hover:bg-slate-100 flex items-center justify-center gap-2" data-type="sine">
                            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 12c2.5-6 6-6 9 0s7.5 6 11 0" stroke-linecap="round"/></svg>
                            正弦波 (Sine)
                        </button>
                        <!-- 方波按鈕 -->
                        <button class="btn-wave px-3 py-2 border rounded-lg text-sm font-medium transition-colors bg-white hover:bg-slate-100 flex items-center justify-center gap-2" data-type="square">
                            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h5V7h6v10h6v-5h1" stroke-linecap="round"/></svg>
                            方波 (Square)
                        </button>
                        <!-- 鋸齒波按鈕 -->
                        <button class="btn-wave px-3 py-2 border rounded-lg text-sm font-medium transition-colors bg-white hover:bg-slate-100 flex items-center justify-center gap-2" data-type="sawtooth">
                             <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 18L10 6v12l6-12v12l4-8" stroke-linecap="round"/></svg>
                            鋸齒波 (Sawtooth)
                        </button>
                        <!-- 三角波按鈕 -->
                        <button class="btn-wave px-3 py-2 border rounded-lg text-sm font-medium transition-colors bg-white hover:bg-slate-100 flex items-center justify-center gap-2" data-type="triangle">
                            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 18L12 6l9 12" stroke-linecap="round" stroke-linejoin="round"/></svg>
                            三角波 (Triangle)
                        </button>
                    </div>
                </div>

            </div>

            <!-- 音量控制 -->
            <div class="bg-slate-50 p-4 rounded-xl border border-slate-100">
                <div class="flex justify-between mb-2">
                    <label class="font-bold text-slate-700 flex items-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"/></svg>
                        音量 (Gain)
                    </label>
                    <span id="vol-display" class="text-sm font-mono text-slate-500">50%</span>
                </div>
                <input type="range" id="vol-slider" min="0" max="100" value="50" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
            </div>

            <!-- 安全警告 -->
            <div class="text-xs text-slate-400 text-center mt-4">
                警告：請注意音量，尤其是在調整高頻時，高音量可能損傷聽力。
            </div>

        </div>
    </div>

    <script>
        // --- 最小頻率 (Hz) ---
        const MIN_FREQ = 20;
        // --- 最大頻率 (Hz) ---
        const MAX_FREQ = 20000;
        // --- 滑塊最大值 (用於對數計算) ---
        const MAX_SLIDER_VAL = 1000;
        
        // --- Web Audio API 節點與狀態變數 ---
        let audioCtx;           // AudioContext 實例
        let oscillator = null;  // 振盪器節點
        let gainNode = null;    // 增益節點 (音量控制)
        let analyser = null;    // 分析器節點 (示波器數據源)
        let isPlaying = false;  // 播放狀態
        
        // --- 預設值與當前狀態 ---
        let frequency = 440;
        let type = 'sine';      // 預設波形為正弦波
        let volume = 0.5;       // 預設音量 (0.0 到 1.0)

        // --- DOM 元素引用 ---
        const playBtn = document.getElementById('play-btn');
        const iconPlay = document.getElementById('icon-play');
        const iconStop = document.getElementById('icon-stop');
        const playText = document.getElementById('play-text');
        
        const freqSlider = document.getElementById('freq-slider');
        const freqInput = document.getElementById('freq-input');
        const volSlider = document.getElementById('vol-slider');
        const volDisplay = document.getElementById('vol-display');
        const hzDisplayCanvas = document.getElementById('hz-display-canvas');
        
        const waveButtons = document.querySelectorAll('.btn-wave');
        const canvas = document.getElementById('oscilloscope');
        const canvasCtx = canvas.getContext('2d');
        
        // --------------------------------------------------------------------------------
        // --- 對數頻率計算邏輯 (Logarithmic Frequency Scaling) ---
        // 人耳對頻率的感知是對數的，因此將線性滑塊值轉換為對數頻率值。
        // --------------------------------------------------------------------------------

        // 將線性滑塊值 (0-1000) 轉換為對數頻率值 (20-20000 Hz)
        function calculateLogFreq(sliderValue) {
            // 由於 Math.log(0) 是 -Infinity，滑塊最小值從 0 開始，因此需要一個映射
            // 這裡使用 1000 範圍的線性值來映射到 [MIN_FREQ, MAX_FREQ] 的對數範圍
            const minLog = Math.log(MIN_FREQ);
            const maxLog = Math.log(MAX_FREQ);
            
            // 計算對數範圍內的目標值
            const scale = (maxLog - minLog) / MAX_SLIDER_VAL;
            
            // 反向計算，將對數值轉換回頻率 (e^x)
            let logFreq = minLog + scale * sliderValue;
            
            // 四捨五入到小數點後一位
            return parseFloat(Math.exp(logFreq).toFixed(1));
        }

        // 將頻率值 (20-20000 Hz) 反向轉換為線性滑塊值 (0-1000)
        function calculateSliderValue(freq) {
            const minLog = Math.log(MIN_FREQ);
            const maxLog = Math.log(MAX_FREQ);
            
            let logFreq = Math.log(freq);
            
            // 計算線性滑塊值
            const sliderValue = (logFreq - minLog) / (maxLog - minLog) * MAX_SLIDER_VAL;
            
            // 四捨五入為整數
            return Math.round(sliderValue);
        }

        // --------------------------------------------------------------------------------
        // --- Web Audio API 處理函數 ---
        // --------------------------------------------------------------------------------

        // 初始化 AudioContext
        function initAudio() {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                // 盡可能在用戶互動後才創建 AudioContext
                audioCtx = new AudioContext();
            }
        }

        // 開始播放音調
        function startTone() {
            initAudio(); // 確保 AudioContext 已初始化
            if (audioCtx.state === 'suspended') {
                audioCtx.resume(); // 喚醒懸停的 AudioContext (例如首次用戶互動後)
            }
            
            // 創建音頻節點
            oscillator = audioCtx.createOscillator();
            gainNode = audioCtx.createGain();
            analyser = audioCtx.createAnalyser();

            // 設定振盪器參數
            oscillator.type = type;
            // 立即設定頻率
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            
            // 設定增益 (音量) - 平滑地從 0 漸變到目標音量，避免點擊雜音
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + 0.05);

            // 分析器配置
            analyser.fftSize = 2048; // 用於視覺化的 FFT 緩衝區大小

            // 連接音頻圖：振盪器 -> 增益 -> 分析器 -> 輸出
            oscillator.connect(gainNode);
            gainNode.connect(analyser);
            analyser.connect(audioCtx.destination); // 連接到揚聲器

            oscillator.start();
            
            isPlaying = true;
            updatePlayButton();
            // 啟動視覺化循環
            drawOscilloscope();
        }

        // 停止播放音調
        function stopTone() {
            if (oscillator) {
                // 平滑地淡出音量
                gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
                
                // 在淡出後停止振盪器，釋放資源
                setTimeout(() => {
                    if (oscillator) {
                        try {
                            oscillator.stop();
                            // 斷開所有連接
                            oscillator.disconnect();
                            gainNode.disconnect();
                            analyser.disconnect();
                        } catch (e) {
                            // 處理節點可能已經停止的錯誤
                            console.error("Error stopping oscillator:", e);
                        }
                    }
                    // 重置節點引用
                    oscillator = null;
                    gainNode = null;
                    analyser = null;
                }, 50); // 確保在淡出時間 (0.05秒) 後執行
            }
            isPlaying = false;
            updatePlayButton();
            // 繪製靜態波形線
            drawOscilloscope();
        }

        // 播放/停止切換
        function togglePlay() {
            if (isPlaying) {
                stopTone();
            } else {
                startTone();
            }
        }

        // 更新播放按鈕的 UI
        function updatePlayButton() {
            if (isPlaying) {
                // 設置為停止狀態的樣式
                playBtn.classList.remove('border-green-500', 'hover:bg-green-50');
                playBtn.classList.add('border-red-500', 'bg-red-50', 'hover:bg-red-100');
                iconPlay.classList.add('hidden');
                iconStop.classList.remove('hidden');
                playText.textContent = "停止";
                playText.classList.replace('text-slate-600', 'text-red-500');
            } else {
                // 設置為播放狀態的樣式
                playBtn.classList.add('border-green-500', 'hover:bg-green-50');
                playBtn.classList.remove('border-red-500', 'bg-red-50', 'hover:bg-red-100');
                iconPlay.classList.remove('hidden');
                iconStop.classList.add('hidden');
                playText.textContent = "播放";
                playText.classList.replace('text-red-500', 'text-slate-600');
            }
        }

        // --------------------------------------------------------------------------------
        // --- 控制輸入處理函數 ---
        // --------------------------------------------------------------------------------

        // 根據滑塊值更新頻率 (主要用於滑塊拖曳)
        function updateFrequencyFromSlider(sliderValue) {
            frequency = calculateLogFreq(sliderValue);
            updateFrequencyUI(frequency);
            updateOscillatorFrequency();
        }

        // 根據頻率值更新所有控制項 (主要用於數字輸入或快速按鈕)
        function updateFrequencyFromValue(val) {
            let newFreq = parseFloat(val);
            
            // 頻率邊界檢查
            if (isNaN(newFreq) || newFreq < MIN_FREQ) {
                newFreq = MIN_FREQ;
            } else if (newFreq > MAX_FREQ) {
                newFreq = MAX_FREQ;
            }
            
            frequency = parseFloat(newFreq.toFixed(1)); // 保持小數點後一位
            
            // 更新 UI
            updateFrequencyUI(frequency);
            
            // 反向計算滑塊位置
            const sliderValue = calculateSliderValue(frequency);
            freqSlider.value = sliderValue;

            updateOscillatorFrequency();
        }

        // 統一更新所有頻率相關的 UI 顯示
        function updateFrequencyUI(freq) {
            const displayFreq = freq.toFixed(1);
            freqInput.value = displayFreq;
            hzDisplayCanvas.innerText = displayFreq;
        }

        // 實際更新振盪器節點的頻率
        function updateOscillatorFrequency() {
            if (oscillator && audioCtx) {
                // 使用 setTargetAtTime 進行微小的平滑調整，防止高頻率產生雜音
                const timeConstant = 0.005; // 5ms 的平滑時間
                oscillator.frequency.setTargetAtTime(frequency, audioCtx.currentTime, timeConstant);
            }
        }
        
        // 外部呼叫函數：調整八度 (降八度/升八度)
        window.adjustOctave = function(factor) {
            // 頻率乘上因子，並進行邊界檢查
            let newFreq = Math.round(frequency * factor);
            if (newFreq < MIN_FREQ) newFreq = MIN_FREQ;
            if (newFreq > MAX_FREQ) newFreq = MAX_FREQ;
            updateFrequencyFromValue(newFreq);
        };
        
        // 外部呼叫函數：設定特定頻率
        window.setFreq = function(val) {
            updateFrequencyFromValue(val);
        };

        // --------------------------------------------------------------------------------
        // --- 視覺化邏輯 (Oscilloscope) ---
        // --------------------------------------------------------------------------------

        // 調整 Canvas 大小以匹配其父容器
        function resizeCanvas() {
            // 必須同時設置 DOM 屬性和 Canvas 屬性
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            // 如果沒有播放，重繪靜態波形線
            if (!isPlaying) drawOscilloscope();
        }
        window.addEventListener('resize', resizeCanvas);


        // 繪製示波器波形
        function drawOscilloscope() {
            // 如果停止播放，只繪製靜態中線
            if (!isPlaying || !analyser) {
                // 清空畫布
                canvasCtx.fillStyle = '#000';
                canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 繪製靜態中線
                canvasCtx.lineWidth = 2;
                canvasCtx.strokeStyle = '#22c55e'; // 螢光綠色
                canvasCtx.beginPath();
                canvasCtx.moveTo(0, canvas.height/2);
                canvasCtx.lineTo(canvas.width, canvas.height/2);
                canvasCtx.stroke();
                return; // 不再請求下一幀
            }

            // 請求下一幀動畫，形成循環
            requestAnimationFrame(drawOscilloscope);

            const bufferLength = analyser.frequencyBinCount;
            // 使用 Float32Array 獲取高精度時間域數據 (值範圍 -1.0 到 1.0)
            const dataArray = new Float32Array(bufferLength);
            analyser.getFloatTimeDomainData(dataArray);

            // 清空畫布
            canvasCtx.fillStyle = '#000';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#22c55e'; // 示波器螢光綠
            canvasCtx.lineJoin = 'round';
            canvasCtx.beginPath();

            const sliceWidth = canvas.width * 1.0 / bufferLength;
            let x = 0;

            // --- 零點觸發 (Zero-Crossing Trigger) ---
            // 尋找波形從負值 (低於 0) 穿越到非負值 (高於或等於 0) 的點，以鎖定波形相位
            let zeroCross = 0;
            for(let i = 0; i < bufferLength - 1; i++) {
                if(dataArray[i] < 0 && dataArray[i+1] >= 0) {
                    zeroCross = i;
                    break;
                }
            }

            // 從找到的零點開始繪製波形，使波形在畫布上看起來是靜止的
            for(let i = zeroCross; i < bufferLength; i++) {
                const v = dataArray[i]; // -1.0 到 1.0
                // 將音頻值映射到畫布高度 (注意：Canvas 的 Y 軸向下為正)
                // y = height/2 - v * (height/2)
                const y = (canvas.height / 2) - (v * (canvas.height / 2));

                if(i === zeroCross) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }

                x += sliceWidth;
                // 如果 X 座標超出畫布寬度則停止繪製
                if (x > canvas.width) break;
            }

            canvasCtx.stroke();
        }

        // --------------------------------------------------------------------------------
        // --- 事件監聽器與初始化 ---
        // --------------------------------------------------------------------------------

        // 初始化頻率滑塊位置和 UI 顯示
        function initializeControls() {
            // 預設頻率為 440 Hz
            updateFrequencyFromValue(frequency); 
            // 預設滑塊值 (對應 440 Hz)
            freqSlider.value = calculateSliderValue(440);
        }
        
        // 播放/停止按鈕點擊事件
        playBtn.addEventListener('click', togglePlay);

        // 頻率滑塊輸入事件 (input: 連續觸發)
        freqSlider.addEventListener('input', (e) => {
            updateFrequencyFromSlider(e.target.value);
        });
        
        // 頻率數字輸入框改變事件 (change: 失去焦點或按 Enter 時觸發)
        freqInput.addEventListener('change', (e) => {
            updateFrequencyFromValue(e.target.value);
        });

        // 音量滑塊輸入事件
        volSlider.addEventListener('input', (e) => {
            const rawVal = e.target.value;
            volume = rawVal / 100; // 0-100 轉換為 0.0-1.0
            volDisplay.innerText = rawVal + "%";
            
            if (gainNode && audioCtx) {
                // 使用 setTargetAtTime 進行平滑音量調整，防止 'zipper noise'
                const timeConstant = 0.01; // 10ms 平滑
                gainNode.gain.setTargetAtTime(volume, audioCtx.currentTime, timeConstant);
            }
        });

        // 波形按鈕事件
        waveButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                // UI 更新：移除所有按鈕的 active 狀態
                waveButtons.forEach(b => b.classList.remove('active'));
                // 為當前點擊的按鈕添加 active 狀態
                btn.classList.add('active');
                
                // 音頻更新
                type = btn.dataset.type;
                if (oscillator) {
                    // 即時更新振盪器波形類型
                    oscillator.type = type;
                }
                // 重新繪製靜態波形線以預覽波形
                if (!isPlaying) {
                    // 為了預覽波形，我們暫時創建一個離線 Context 來獲取波形數據
                    // 由於這裡的視覺化依賴 AnalyserNode，暫時不播放時不做預覽切換，僅更新設定。
                    // 為了簡潔，我們只讓正在播放時才顯示不同的波形。
                    drawOscilloscope(); 
                }
            });
        });

        // 首次加載時執行
        window.onload = function() {
            // 1. 初始化控制項的數值和滑塊位置
            initializeControls(); 
            // 2. 初始化畫布尺寸
            resizeCanvas(); 
            // 3. 繪製預設的靜態線
            drawOscilloscope();
        }

    </script>
</body>
</html>
