<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>垂直自由落體運動分析</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f4f8;
        }

        h1 {
            color: #1e3a8a;
            border-bottom: 2px solid #bfdbfe;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .video-tracking-area {
            position: relative;
            width: 95%; 
            max-width: 600px; 
            margin: 20px auto;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
        }

        #tracking-canvas {
            border: 3px solid #1e3a8a;
            cursor: crosshair;
            display: block;
            background-color: #000;
            touch-action: none;
            display: block;
            width: auto;        
            height: auto;       
            max-width: 100%;    
        }

        #video-player {
            width: 100%;
            height: auto;
            display: none !important;
        }

        .controls-container {
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }

        h2 {
            color: #3b82f6;
            margin-top: 5px;
            margin-bottom: 10px;
        }

        hr {
            border: 0;
            height: 1px;
            background-color: #e5e7eb;
            margin: 15px 0;
        }

        button {
            background-color: #3b82f6;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: 600;
        }

        button.nav-btn {
            width: 48%; 
        }
        
        button:hover {
            background-color: #2563eb;
        }
        
        button:disabled {
            background-color: #9ca3af !important;
            cursor: not-allowed;
        }

        button.btn-danger {
            background-color: #ef4444;
        }
        button.btn-danger:hover {
            background-color: #dc2626;
        }

        button.btn-pink {
            background-color: #ec4899; 
        }
        button.btn-pink:hover {
            background-color: #db2777; 
        }

        button.btn-success {
            background-color: #10b981;
        }
        button.btn-success:hover {
            background-color: #059669;
        }
        
        input[type="file"], input[type="number"], select { 
            padding: 8px;
            margin-right: 8px;
            margin-bottom: 10px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
        }
        
        label {
            margin-right: 8px;
            margin-bottom: 10px;
            display: inline-block; 
        }

        .status-message {
            font-style: italic;
            color: #4b5563;
            margin-top: 10px;
            padding: 5px 0;
        }

        .results-container {
            margin-top: 30px;
            padding: 20px;
            border-radius: 8px;
            background-color: #ffffff;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }

        #analysis-output {
            background-color: #f9fafb;
            padding: 15px;
            border-radius: 4px;
            white-space: pre-wrap;
            overflow-x: auto;
            font-family: monospace;
            border: 1px dashed #e5e7eb;
        }
        
        #graph-area, #velocity-graph-area, #acceleration-graph-area {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
        }

        .chart-container {
            position: relative;
            height: 400px; 
            width: 100%;
        }

        .graph-controls {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .controls-container > div {
            margin-bottom: 10px;
        }
        .controls-container label, .controls-container input, .controls-container select {
            vertical-align: middle;
        }

        .app-footer {
            margin-top: 40px;
            padding: 20px 0;
            text-align: center;
            font-size: 0.875rem; 
            color: #6b7280; 
            border-top: 1px solid #e5e7eb; 
        }
        
        .keyboard-hint {
            font-size: 0.8em;
            color: #6b7280;
            display: block;
            margin-top: 5px;
        }
        
        @media (max-width: 768px) {
            .mobile-tip { display: block; }
        }
    </style>
</head>
<body>
    <h1>垂直自由落體運動分析</h1>
    <p>上傳物體下落的影片片段，校準比例尺，並逐幀標記物體位置以產生運動圖表。</p>

    <div class="controls-container">
        <div style="display: flex; flex-wrap: wrap; gap: 20px; align-items: flex-end;">
            <div>
                <label for="video-file-input" style="font-weight: bold; display:block;">步驟 0: 選擇影片片段:</label>
                <input type="file" id="video-file-input" accept="video/*">
            </div>
        </div>
    </div>

    <div class="video-tracking-area">
        <video id="video-player" width="640" height="480" controls playsinline webkit-playsinline></video>
        <canvas id="tracking-canvas" width="640" height="480"></canvas>
    </div>

    <div class="controls-container">
        <h2>1. 校準 (比例尺)</h2>
        <label for="known-length-input">已知長度:</label>
        <input type="number" id="known-length-input" value="1.0" min="0.01" inputmode="decimal">
        <select id="unit-select">
            <option value="m">米 (m)</option>
        </select>
        <button id="calibrate-btn">開始校準</button>
        <p id="calibration-status" class="status-message">比例尺: 請載入影片並進行校準。</p>
        
        <hr>

        <h2>2. 追蹤</h2>
        <div style="display: flex; gap: 4%; margin-bottom: 10px;">
            <button id="prev-frame-btn" class="nav-btn" disabled>← 上一幀 (左箭頭)</button>
            <button id="next-frame-btn" class="nav-btn" disabled>下一幀 (右箭頭) →</button>
        </div>
        
        <p style="margin-top: 10px;">點擊畫面中的物體以標記其中心。每幀只允許一個點。</p>
        
        <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="undo-btn" disabled>移除當前幀標記</button>
            <button id="clear-data-btn" class="btn-pink" disabled>清除所有數據</button>
        </div>
        
        <p id="tracking-status" class="status-message">追蹤點數: 0 | 當前時間: <i>t</i> = 0.000 s</p>

        <hr>

        <h2>3. 分析</h2>
        <div style="display: flex; gap: 10px;">
            <button id="analyze-btn" disabled>產生分析</button>
            <button id="export-btn" class="btn-success" disabled>匯出 CSV</button>
        </div>
    </div>

    <div class="results-container">
        <h3>原始數據輸出</h3>
        <pre id="analysis-output">載入影片、校準、追蹤點數，然後點擊「產生分析」以在此處查看結果。</pre>

        <div id="graph-area">
            <h3>位置-時間圖表</h3>
            <div class="graph-controls">
                <input type="checkbox" id="regression-checkbox" checked>
                <label for="regression-checkbox">顯示二次迴歸 (y = At² + Bt + C)</label>
                <span id="r-squared-display" style="font-weight: bold; color: #059669;"></span>
            </div>
            <div class="chart-container">
                <canvas id="position-time-chart"></canvas>
            </div>
        </div>
        
        <div id="velocity-graph-area">
            <h3>速度-時間圖表</h3>
            <div class="chart-container">
                <canvas id="velocity-time-chart"></canvas>
            </div>
        </div>

        <div id="acceleration-graph-area">
            <h3>加速度-時間圖表</h3>
            <div class="chart-container">
                <canvas id="acceleration-time-chart"></canvas>
            </div>
        </div>
    </div>
    
    <footer class="app-footer">
        廠商會中學 · 物理科
    </footer>

    <script>
        let videoPlayer = document.getElementById('video-player');
        let trackingCanvas = document.getElementById('tracking-canvas');
        let trackingCtx = trackingCanvas.getContext('2d');
        
        const prevFrameBtn = document.getElementById('prev-frame-btn');
        const nextFrameBtn = document.getElementById('next-frame-btn');
        const undoBtn = document.getElementById('undo-btn');
        const clearDataBtn = document.getElementById('clear-data-btn');
        const analyzeBtn = document.getElementById('analyze-btn');
        const exportBtn = document.getElementById('export-btn');
        const regressionCheckbox = document.getElementById('regression-checkbox');
        const rSquaredDisplay = document.getElementById('r-squared-display');
        const calibrateBtn = document.getElementById('calibrate-btn');
        // No manual FPS input anymore

        let isCalibrating = false;
        let calibrationPoints = [];
        let trackedData = []; 
        let scaleFactor = 0; 
        
        let positionTimeChart = null; 
        let velocityTimeChart = null; 
        let accelerationTimeChart = null; 
        let regressionCoeffs = [0, 0, 0]; 

        const FRAME_STEP = 1 / 30; 
        
        const DEFAULT_OPACITY = 0.6; 
        const TRACKING_DOT_COLOR = 'rgba(239, 68, 68, 0.6)'; 
        const CALIBRATION_COLOR_BASE = 'rgba(74, 222, 128, 0.6)'; 
        
        const TOUCH_OFFSET_Y = 70; 
        let isDragging = false;
        let dragTarget = null; 
        let hoverPos = null;

        let draggingCalibIndex = -1; 
        const HIT_RADIUS = 30; 
        
        const MAGNIFIER_RADIUS = 50; 
        const MAGNIFIER_ZOOM = 2;

        function showMessage(message) {
            console.warn("User Message Box: " + message);
            const outputElement = document.getElementById('analysis-output');
            const tempMessage = document.createElement('div');
            tempMessage.textContent = `[注意]: ${message}`;
            tempMessage.style.color = '#dc2626'; 
            tempMessage.style.fontWeight = 'bold';
            tempMessage.style.padding = '10px 0';
            outputElement.insertAdjacentElement('beforebegin', tempMessage);
            setTimeout(() => tempMessage.remove(), 5000); 
        }

        // --- Recalculate Real World Coords (Improvement 1) ---
        // Updates all tracked points based on the current scaleFactor
        const recalculateAllPoints = () => {
            if (scaleFactor <= 0) return;
            trackedData.forEach(p => {
                // p.y_px is the source of truth
                p.y_real = (trackingCanvas.height - p.y_px) * scaleFactor;
            });
        };

        const drawCurrentFrame = () => {
            if (videoPlayer.readyState < 2) return; 

            const currentTime = videoPlayer.currentTime.toFixed(3);
            
            trackingCtx.clearRect(0, 0, trackingCanvas.width, trackingCanvas.height);
            trackingCtx.drawImage(videoPlayer, 0, 0, trackingCanvas.width, trackingCanvas.height);

            // Draw Calibration
            if (calibrationPoints.length > 0) {
                if (calibrationPoints.length === 2) {
                    const p1 = calibrationPoints[0];
                    const p2 = calibrationPoints[1];
                    trackingCtx.save();
                    trackingCtx.strokeStyle = CALIBRATION_COLOR_BASE; 
                    trackingCtx.lineWidth = 3;
                    trackingCtx.beginPath();
                    trackingCtx.moveTo(p1.x, p1.y);
                    trackingCtx.lineTo(p2.x, p2.y);
                    trackingCtx.stroke();
                    trackingCtx.restore();
                }

                calibrationPoints.forEach((p, idx) => {
                    const label = `校準點${idx + 1}`;
                    drawMarker(p.x, p.y, CALIBRATION_COLOR_BASE, label, DEFAULT_OPACITY);
                });
            }
            
            // Draw Tracking Data
            trackedData.forEach(p => {
                const opacity = (p.time.toFixed(3) === currentTime) ? 1.0 : DEFAULT_OPACITY;
                drawMarker(p.x_px, p.y_px, TRACKING_DOT_COLOR, `t = ${p.time.toFixed(3)} s`, opacity);
            });
            
            // Draw active drag crosshair (for tracking placement)
            if (dragTarget) {
                drawMagnifier(dragTarget.x, dragTarget.y);
            } 
            // Draw Hover Magnifier
            else if (hoverPos) {
                 drawMagnifier(hoverPos.x, hoverPos.y);
            }

            const formattedTime = videoPlayer.currentTime.toFixed(3);
            document.getElementById('tracking-status').innerHTML = 
                `追蹤點數: ${trackedData.length} | 當前時間: <i>t</i> = ${formattedTime} s`;
            
            prevFrameBtn.disabled = videoPlayer.currentTime <= 0.01;
            
            const hasData = trackedData.length > 0;
            clearDataBtn.disabled = !hasData;
            undoBtn.disabled = (trackedData.length === 0 && videoPlayer.currentTime <= 0.01);
            exportBtn.disabled = !hasData;
        };

        const drawMarker = (x, y, color, label, opacity = 1.0) => {
            trackingCtx.save();
            trackingCtx.globalAlpha = opacity;

            trackingCtx.beginPath();
            trackingCtx.arc(x, y, 7, 0, Math.PI * 2);
            trackingCtx.fillStyle = color; 
            trackingCtx.fill();
            trackingCtx.lineWidth = 2;
            trackingCtx.strokeStyle = 'white';
            trackingCtx.stroke();
            
            trackingCtx.globalAlpha = 1.0; 
            trackingCtx.strokeStyle = 'white';
            trackingCtx.lineWidth = 1;
            const crossSize = 3; 
            
            trackingCtx.beginPath();
            trackingCtx.moveTo(x - crossSize, y);
            trackingCtx.lineTo(x + crossSize, y);
            trackingCtx.moveTo(x, y - crossSize);
            trackingCtx.lineTo(x, y + crossSize);
            trackingCtx.stroke();

            if (label) {
                trackingCtx.globalAlpha = 1.0;
                trackingCtx.font = '12px Inter';
                trackingCtx.fillStyle = 'white';
                trackingCtx.fillText(label, x + 8, y + 5);
            }
            trackingCtx.restore();
        };
        
        // Improvement 2: Magnifier boundary clamping
        const drawMagnifier = (x, y) => {
            trackingCtx.save();
            
            trackingCtx.beginPath();
            trackingCtx.arc(x, y, MAGNIFIER_RADIUS, 0, Math.PI * 2);
            trackingCtx.closePath();
            
            trackingCtx.save();
            trackingCtx.clip();
            
            const srcR = MAGNIFIER_RADIUS / MAGNIFIER_ZOOM;
            const srcD = srcR * 2;
            const destD = MAGNIFIER_RADIUS * 2;
            
            // Calculate source coordinates
            let sx = x - srcR;
            let sy = y - srcR;

            // Optional: Clamp source to video boundaries to prevent drawing empty pixels
            // However, drawImage generally handles out-of-bounds gracefully (draws nothing/transparent)
            // But filling black background handles the visual aspect.
            
            trackingCtx.fillStyle = 'black';
            trackingCtx.fill();
            
            try {
                trackingCtx.drawImage(
                    videoPlayer, 
                    sx, sy, srcD, srcD, 
                    x - MAGNIFIER_RADIUS, y - MAGNIFIER_RADIUS, destD, destD 
                );
            } catch (e) {
                // Ignore errors
            }
            
            trackingCtx.restore();

            trackingCtx.globalAlpha = 1.0;
            trackingCtx.strokeStyle = '#fff';
            trackingCtx.lineWidth = 3;
            trackingCtx.stroke(); 
            trackingCtx.strokeStyle = '#3b82f6'; 
            trackingCtx.lineWidth = 1;
            trackingCtx.stroke();

            trackingCtx.strokeStyle = '#3b82f6'; 
            trackingCtx.lineWidth = 1;
            const size = 10;

            trackingCtx.beginPath();
            trackingCtx.moveTo(x - size, y);
            trackingCtx.lineTo(x + size, y);
            trackingCtx.moveTo(x, y - size);
            trackingCtx.lineTo(x, y + size);
            trackingCtx.stroke();
            
            trackingCtx.restore();
        };

        const calculateScale = () => {
            if (calibrationPoints.length < 2) return;
            const p1 = calibrationPoints[0];
            const p2 = calibrationPoints[1];
            const pixelDistance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            const knownLength = parseFloat(document.getElementById('known-length-input').value);
            const unit = document.getElementById('unit-select').value;
            
            if (pixelDistance > 0 && knownLength > 0) {
                scaleFactor = knownLength / pixelDistance;
                document.getElementById('calibration-status').textContent = 
                    `已校準: 1 像素 = ${scaleFactor.toFixed(4)} ${unit}。準備追蹤。`;
                
                // Improvement 1: Recalculate existing points if scale changes
                recalculateAllPoints();

            } else {
                document.getElementById('calibration-status').textContent = '校準數值無效。';
                scaleFactor = 0;
            }
        };

        const exitCalibrationMode = () => {
            if (!isCalibrating) return;
            
            isCalibrating = false;
            calibrateBtn.classList.remove('btn-success');
            
            if (calibrationPoints.length === 2) {
                calculateScale();
                calibrateBtn.textContent = '重新校準';
                analyzeBtn.disabled = false;
            } else {
                calibrationPoints = [];
                scaleFactor = 0;
                calibrateBtn.textContent = '開始校準';
                document.getElementById('calibration-status').textContent = '校準已取消 (切換幀)。';
            }
            drawCurrentFrame(); 
        };

        document.getElementById('video-file-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                trackedData = [];
                scaleFactor = 0;
                regressionCoeffs = [0, 0, 0];
                document.getElementById('tracking-status').innerHTML = '追蹤點數: 0 | 當前時間: <i>t</i> = 0.000 s';
                document.getElementById('calibration-status').textContent = '影片已載入。準備校準。';
                nextFrameBtn.disabled = true;
                prevFrameBtn.disabled = true;
                undoBtn.disabled = true;
                analyzeBtn.disabled = true;
                clearDataBtn.disabled = true;
                exportBtn.disabled = true;
                
                if (positionTimeChart) positionTimeChart.destroy();
                if (velocityTimeChart) velocityTimeChart.destroy();
                if (accelerationTimeChart) accelerationTimeChart.destroy();

                document.getElementById('analysis-output').textContent = '影片已載入。請校準並追蹤點數。';
                rSquaredDisplay.textContent = '';
                
                videoPlayer.src = URL.createObjectURL(file);
                videoPlayer.load();

                videoPlayer.onloadedmetadata = () => {
                    trackingCanvas.width = videoPlayer.videoWidth;
                    trackingCanvas.height = videoPlayer.videoHeight;
                    
                    videoPlayer.currentTime = 0; 
                    videoPlayer.addEventListener('seeked', drawCurrentFrame, { once: true });
                    nextFrameBtn.disabled = false;
                    prevFrameBtn.disabled = true;
                };
            }
        });
        
        const advanceFrame = (step) => {
            if (isCalibrating) {
                exitCalibrationMode();
            }

            if (videoPlayer.src) {
                videoPlayer.pause();
                const newTime = Math.max(0, videoPlayer.currentTime + step);
                videoPlayer.currentTime = parseFloat((Math.round(newTime / FRAME_STEP) * FRAME_STEP).toFixed(3));
                videoPlayer.addEventListener('seeked', drawCurrentFrame, { once: true });
            }
        };

        nextFrameBtn.addEventListener('click', () => advanceFrame(FRAME_STEP));
        prevFrameBtn.addEventListener('click', () => advanceFrame(-FRAME_STEP));

        document.addEventListener('keydown', (e) => {
            if (!videoPlayer.src) return;
            if (e.key === "ArrowRight") {
                e.preventDefault(); 
                advanceFrame(FRAME_STEP);
            } else if (e.key === "ArrowLeft") {
                e.preventDefault();
                advanceFrame(-FRAME_STEP);
            }
        });

        calibrateBtn.addEventListener('click', () => {
            if (!videoPlayer.src) {
                showMessage("請先載入影片。");
                return;
            }

            if (!isCalibrating) {
                isCalibrating = true;
                calibrationPoints = [];
                scaleFactor = 0;
                calibrateBtn.textContent = '完成校準';
                calibrateBtn.classList.add('btn-success'); 
                document.getElementById('calibration-status').textContent = '校準模式: 點擊兩點，可拖曳調整。完成後點擊「完成校準」。';
                analyzeBtn.disabled = true;
                drawCurrentFrame();
            } else {
                if (calibrationPoints.length === 2) {
                    calculateScale(); 
                    isCalibrating = false;
                    calibrateBtn.textContent = '重新校準';
                    calibrateBtn.classList.remove('btn-success');
                    analyzeBtn.disabled = false;
                } else {
                    alert("請設定兩個校準點。");
                }
            }
        });

        const processPointSelection = (x, y) => {
            if (!videoPlayer.src) return;
            
            if (x < 0 || x > trackingCanvas.width || y < 0 || y > trackingCanvas.height) {
                return;
            }

            if (isCalibrating) {
                if (draggingCalibIndex !== -1) {
                    calibrationPoints[draggingCalibIndex] = { x, y };
                    draggingCalibIndex = -1; 
                } else {
                    if (calibrationPoints.length < 2) {
                         calibrationPoints.push({ x, y });
                    }
                }
            } else {
                trackPosition(x, y);
                setTimeout(() => advanceFrame(FRAME_STEP), 150);
            }
            drawCurrentFrame();
        };

        const getEventPos = (e) => {
            const rect = trackingCanvas.getBoundingClientRect();
            const scaleX = trackingCanvas.width / rect.width;
            const scaleY = trackingCanvas.height / rect.height;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        };

        const handleStart = (e) => {
            if (!videoPlayer.src) return;
            e.preventDefault(); 

            const pos = getEventPos(e);
            
            if (isCalibrating) {
                draggingCalibIndex = -1;
                for (let i = calibrationPoints.length - 1; i >= 0; i--) {
                    const p = calibrationPoints[i];
                    const rect = trackingCanvas.getBoundingClientRect();
                    const scaleX = trackingCanvas.width / rect.width;
                    const scaledHitRadius = HIT_RADIUS * scaleX; 

                    const dist = Math.sqrt(Math.pow(pos.x - p.x, 2) + Math.pow(pos.y - p.y, 2));
                    
                    if (dist < scaledHitRadius) {
                        draggingCalibIndex = i;
                        isDragging = true;
                        break; 
                    }
                }
                
                if (draggingCalibIndex === -1 && calibrationPoints.length < 2) {
                    isDragging = true;
                }
            } else {
                isDragging = true;
            }
            
            if (isDragging) {
                 const rect = trackingCanvas.getBoundingClientRect();
                 const scaleY = trackingCanvas.height / rect.height;
                 const offsetY = (e.type === 'touchstart') ? (TOUCH_OFFSET_Y * scaleY) : 0;
                 
                 dragTarget = { x: pos.x, y: pos.y - offsetY };
                 drawCurrentFrame();
            }
        };

        const handleMove = (e) => {
             if (e.type === 'mousemove' && !isDragging) {
                 hoverPos = getEventPos(e);
                 drawCurrentFrame();
                 return;
             }
            
            if (!isDragging) return;
            e.preventDefault();

            const pos = getEventPos(e);
            
            const rect = trackingCanvas.getBoundingClientRect();
            const scaleY = trackingCanvas.height / rect.height;
            const offsetY = (e.type === 'touchmove' || e.type === 'touchstart') ? (TOUCH_OFFSET_Y * scaleY) : 0;
                
            dragTarget = { x: pos.x, y: pos.y - offsetY };
            
            if (isCalibrating && draggingCalibIndex !== -1) {
                calibrationPoints[draggingCalibIndex] = { x: dragTarget.x, y: dragTarget.y };
            }

            drawCurrentFrame();
        };
        
        trackingCanvas.addEventListener('mouseout', () => {
            hoverPos = null;
            drawCurrentFrame();
        });

        const handleEnd = (e) => {
            if (e.type === 'touchend') e.preventDefault();
            
            if (isDragging && dragTarget) {
                processPointSelection(dragTarget.x, dragTarget.y);
            }
            
            isDragging = false;
            dragTarget = null;
            drawCurrentFrame();
        };

        trackingCanvas.addEventListener('mousedown', handleStart);
        trackingCanvas.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', () => { if(isDragging) handleEnd({ preventDefault: ()=>{} }); }); 

        trackingCanvas.addEventListener('touchstart', handleStart, { passive: false });
        trackingCanvas.addEventListener('touchmove', handleMove, { passive: false });
        trackingCanvas.addEventListener('touchend', handleEnd);

        const trackPosition = (x, y) => {
            if (scaleFactor === 0) {
                showMessage("請在追蹤點數前先校準影片。");
                return;
            }
            
            const currentTime = videoPlayer.currentTime.toFixed(3);
            const existingIndex = trackedData.findIndex(p => p.time.toFixed(3) === currentTime);
            const y_real = (trackingCanvas.height - y) * scaleFactor;

            const newPoint = {
                time: videoPlayer.currentTime,
                x_px: x,
                y_px: y,
                y_real: y_real,
                v_real: null, 
                a_real: null
            };

            if (existingIndex !== -1) {
                trackedData[existingIndex] = newPoint;
            } else {
                trackedData.push(newPoint);
                trackedData.sort((a, b) => a.time - b.time); 
            }
            undoBtn.disabled = trackedData.length === 0;
        };


        // Feature 4: Clear Data Function (Optimized with Timeout)
        let clearConfirmState = false;
        let clearResetTimer = null; // Improvement 3: Timer

        const resetClearButton = () => {
            clearConfirmState = false;
            clearDataBtn.textContent = '清除所有數據';
            clearDataBtn.classList.remove('btn-danger');
            clearDataBtn.classList.add('btn-pink');
            if (clearResetTimer) clearTimeout(clearResetTimer);
        };

        clearDataBtn.addEventListener('click', (e) => {
            e.stopPropagation();

            if (!clearConfirmState) {
                clearConfirmState = true;
                clearDataBtn.textContent = '確定清除?';
                clearDataBtn.classList.remove('btn-pink');
                clearDataBtn.classList.add('btn-danger');
                
                // Improvement 3: Auto-reset after 3 seconds
                clearResetTimer = setTimeout(resetClearButton, 3000);
                
            } else {
                trackedData = [];
                if (positionTimeChart) { positionTimeChart.destroy(); positionTimeChart = null; }
                if (velocityTimeChart) { velocityTimeChart.destroy(); velocityTimeChart = null; }
                if (accelerationTimeChart) { accelerationTimeChart.destroy(); accelerationTimeChart = null; }
                
                document.getElementById('analysis-output').textContent = '數據已清除。請重新開始追蹤。';
                rSquaredDisplay.textContent = '';
                regressionCoeffs = [0, 0, 0];

                drawCurrentFrame();
                undoBtn.disabled = true;
                
                resetClearButton();
                clearDataBtn.disabled = true;
                exportBtn.disabled = true;
            }
        });

        document.addEventListener('click', () => {
            if (clearConfirmState) {
                resetClearButton();
            }
        });

        undoBtn.addEventListener('click', () => {
            const currentTime = videoPlayer.currentTime.toFixed(3);
            const indexToRemove = trackedData.findIndex(p => p.time.toFixed(3) === currentTime);

            if (indexToRemove !== -1) {
                trackedData.splice(indexToRemove, 1);
                calculateDerivedData(trackedData); 
                renderAllCharts(); 
                
                advanceFrame(-FRAME_STEP);
            } else {
                advanceFrame(-FRAME_STEP);
            }
            
            if (trackedData.length === 0) {
                undoBtn.disabled = true;
            }
        });

        exportBtn.addEventListener('click', () => {
            if (trackedData.length === 0) return;
            calculateDerivedData(trackedData);
            const unit = document.getElementById('unit-select').value;
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "\uFEFF"; 
            csvContent += `時間 / s,垂直位置 / m\n`;
            trackedData.forEach(p => {
                csvContent += `${p.time.toFixed(3)},${p.y_real.toFixed(4)}\n`;
            });
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "motion_analysis_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });


        // --- 4. Analysis Functions ---

        function calculateDerivedData(data) {
            data.forEach(p => { p.v_real = null; p.a_real = null; });
            if (data.length < 3) return;

            for (let i = 1; i < data.length - 1; i++) {
                const y_prev = data[i - 1].y_real;
                const y_next = data[i + 1].y_real;
                const t_prev = data[i - 1].time;
                const t_next = data[i + 1].time;

                if (t_next > t_prev) {
                    data[i].v_real = (y_next - y_prev) / (t_next - t_prev);
                }
            }

            if (data.length < 5) return;
            
            for (let i = 2; i < data.length - 2; i++) {
                 const v_prev = data[i - 1].v_real;
                 const v_next = data[i + 1].v_real;
                 const t_prev = data[i - 1].time;
                 const t_next = data[i + 1].time;
                 
                 if (v_prev !== null && v_next !== null && t_next > t_prev) {
                     data[i].a_real = (v_next - v_prev) / (t_next - t_prev);
                 }
            }
        }

        function quadraticRegression(data) {
            if (data.length < 3) return [0, 0, 0];
            let n = data.length;
            let sum_t = 0, sum_y = 0, sum_t2 = 0, sum_t3 = 0, sum_t4 = 0, sum_yt = 0, sum_yt2 = 0;

            for (let i = 0; i < n; i++) {
                let t = data[i].time;
                let y = data[i].y_real;
                let t2 = t * t;
                let t3 = t2 * t;
                let t4 = t3 * t;
                sum_t += t; sum_y += y; sum_t2 += t2; sum_t3 += t3; sum_t4 += t4; sum_yt += y * t; sum_yt2 += y * t2;
            }

            const a = [[sum_t4, sum_t3, sum_t2], [sum_t3, sum_t2, sum_t], [sum_t2, sum_t, n]];
            const b = [sum_yt2, sum_yt, sum_y];
            
            const D = a[0][0]*(a[1][1]*a[2][2] - a[1][2]*a[2][1]) - a[0][1]*(a[1][0]*a[2][2] - a[1][2]*a[2][0]) + a[0][2]*(a[1][0]*a[2][1] - a[1][1]*a[2][0]);
            if (D === 0) return [0, 0, 0];

            const Da = b[0]*(a[1][1]*a[2][2] - a[1][2]*a[2][1]) - a[0][1]*(b[1]*a[2][2] - a[1][2]*b[2]) + a[0][2]*(b[1]*a[2][1] - a[1][1]*b[2]);
            const Db = a[0][0]*(b[1]*a[2][2] - a[1][2]*b[2]) - b[0]*(a[1][0]*a[2][2] - a[1][2]*a[2][0]) + a[0][2]*(a[1][0]*b[2] - b[1]*a[2][0]);
            const Dc = a[0][0]*(a[1][1]*b[2] - b[1]*a[2][1]) - a[0][1]*(a[1][0]*b[2] - b[1]*a[2][0]) + b[0]*(a[1][0]*a[2][1] - a[1][1]*a[2][0]);
            
            return [Da / D, Db / D, Dc / D];
        }

        function calculateRSquared(data, coeffs) {
            const [A, B, C] = coeffs;
            let sum_y = 0;
            for (let i = 0; i < data.length; i++) sum_y += data[i].y_real;
            const mean_y = sum_y / data.length;
            let ss_tot = 0, ss_res = 0;
            for (let i = 0; i < data.length; i++) {
                const t = data[i].time;
                const y_actual = data[i].y_real;
                const y_predicted = A * t * t + B * t + C;
                ss_tot += Math.pow(y_actual - mean_y, 2);
                ss_res += Math.pow(y_actual - y_predicted, 2);
            }
            if (ss_tot === 0) return 1;
            return 1 - (ss_res / ss_tot);
        }

        const generateRegressionData = (data, coeffs) => {
            if (!coeffs || data.length === 0) return [];
            const [A, B, C] = coeffs;
            const startTime = data[0].time;
            const endTime = data[data.length - 1].time;
            const step = (endTime - startTime) / 100; 
            const regressionPoints = [];
            for (let t = startTime; t <= endTime; t += step) {
                const y = A * t * t + B * t + C;
                regressionPoints.push({ x: t, y: y });
            }
            if (regressionPoints.length > 0 && regressionPoints[regressionPoints.length - 1].x.toFixed(3) !== endTime.toFixed(3)) {
                 const y = A * endTime * endTime + B * endTime + C;
                 regressionPoints.push({ x: endTime, y: y });
            }
            return regressionPoints;
        }

        const renderPositionChart = (minTime, maxTime) => {
            if (trackedData.length < 2) {
                 if (positionTimeChart) positionTimeChart.destroy();
                 rSquaredDisplay.textContent = '';
                 regressionCoeffs = [0, 0, 0];
                 return;
            }

            const unit = document.getElementById('unit-select').value;
            const ctx = document.getElementById('position-time-chart').getContext('2d');
            const showRegression = regressionCheckbox.checked;

            const positionData = trackedData.map(p => ({ x: p.time, y: p.y_real }));
            let datasets = [{
                label: '追蹤位置數據',
                data: positionData,
                backgroundColor: 'rgba(59, 130, 246, 1.0)',
                pointRadius: 6,
                type: 'scatter'
            }];
            
            rSquaredDisplay.textContent = '';
            
            if (showRegression && trackedData.length >= 3) {
                regressionCoeffs = quadraticRegression(trackedData);
                const [A, B, C] = regressionCoeffs;
                const rSquared = calculateRSquared(trackedData, regressionCoeffs);
                const regressionPoints = generateRegressionData(trackedData, regressionCoeffs);
                
                const formulaLabel = `二次迴歸 (y = ${A.toFixed(3)}t² + ${B.toFixed(3)}t + ${C.toFixed(3)})`;

                datasets.push({
                    label: formulaLabel,
                    data: regressionPoints,
                    borderColor: '#ef4444',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    type: 'line',
                    tension: 0
                });
                rSquaredDisplay.textContent = `R²: ${rSquared.toFixed(4)}`;
            } else {
                 regressionCoeffs = [0, 0, 0];
            }

            if (positionTimeChart) positionTimeChart.destroy();

            positionTimeChart = new Chart(ctx, {
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, 
                    scales: {
                        x: { type: 'linear', position: 'bottom', title: { display: true, text: '時間 (s)', font: { size: 14 } }, min: minTime, max: maxTime },
                        y: { title: { display: true, text: `位置 (${unit})`, font: { size: 14 } } }
                    },
                    plugins: { legend: { display: true }, tooltip: { callbacks: { label: function(context) { return `${context.dataset.label}: (t=${context.parsed.x.toFixed(3)} s, y=${context.parsed.y.toFixed(4)} ${unit})`; } } } }
                }
            });
        };
        
        const renderVelocityChart = (minTime, maxTime) => {
             if (!regressionCheckbox.checked || trackedData.length < 3) {
                if (velocityTimeChart) velocityTimeChart.destroy();
                return;
            }

            const unit = document.getElementById('unit-select').value;
            const ctx = document.getElementById('velocity-time-chart').getContext('2d');
            const [A, B] = regressionCoeffs; 

            const startTime = trackedData[0].time;
            const endTime = trackedData[trackedData.length - 1].time;
            const step = (endTime - startTime) / 100;

            const velocityRegressionPoints = [];
            for (let t = startTime; t <= endTime; t += step) {
                const v = 2 * A * t + B;
                velocityRegressionPoints.push({ x: t, y: v });
            }
             if (velocityRegressionPoints.length > 0 && velocityRegressionPoints[velocityRegressionPoints.length - 1].x.toFixed(3) !== endTime.toFixed(3)) {
                 const v = 2 * A * endTime + B;
                 velocityRegressionPoints.push({ x: endTime, y: v });
            }
            
            if (velocityTimeChart) velocityTimeChart.destroy();

            velocityTimeChart = new Chart(ctx, {
                data: {
                    datasets: [{
                        label: `速度 (v = ${ (2 * A).toFixed(3) }t + ${ B.toFixed(3) })`,
                        data: velocityRegressionPoints,
                        borderColor: '#22c55e',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        type: 'line',
                        tension: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, 
                    scales: {
                        x: { type: 'linear', position: 'bottom', title: { display: true, text: '時間 (s)', font: { size: 14 } }, min: minTime, max: maxTime },
                        y: { title: { display: true, text: `速度 (${unit}/s)`, font: { size: 14 } } }
                    },
                    plugins: { legend: { display: true } }
                }
            });
        };
        
        const renderAccelerationChart = (minTime, maxTime) => {
             if (!regressionCheckbox.checked || trackedData.length < 3) {
                if (accelerationTimeChart) accelerationTimeChart.destroy();
                return;
            }

            const unit = document.getElementById('unit-select').value;
            const ctx = document.getElementById('acceleration-time-chart').getContext('2d');
            const [A] = regressionCoeffs;
            const accelerationValue = 2 * A;
            const startTime = trackedData[0].time;
            const endTime = trackedData[trackedData.length - 1].time;

            const accelerationRegressionPoints = [
                { x: startTime, y: accelerationValue },
                { x: endTime, y: accelerationValue }
            ];

            if (accelerationTimeChart) accelerationTimeChart.destroy();

            accelerationTimeChart = new Chart(ctx, {
                data: {
                    datasets: [{
                        label: `加速度 (a = ${ accelerationValue.toFixed(3) })`,
                        data: accelerationRegressionPoints,
                        borderColor: '#f97316',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        type: 'line',
                        tension: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, 
                    scales: {
                        x: { type: 'linear', position: 'bottom', title: { display: true, text: '時間 (s)', font: { size: 14 } }, min: minTime, max: maxTime },
                        y: { title: { display: true, text: `加速度 (${unit}/s²)`, font: { size: 14 } } }
                    },
                    plugins: { legend: { display: true } }
                }
            });
        };
        
        const renderAllCharts = () => {
            if (trackedData.length === 0) {
                 if (positionTimeChart) positionTimeChart.destroy();
                 if (velocityTimeChart) velocityTimeChart.destroy();
                 if (accelerationTimeChart) accelerationTimeChart.destroy();
                 return;
            }
            const minTime = trackedData[0].time;
            const maxTime = trackedData[trackedData.length - 1].time;
            renderPositionChart(minTime, maxTime); 
            renderVelocityChart(minTime, maxTime);
            renderAccelerationChart(minTime, maxTime);
        }
        
        regressionCheckbox.addEventListener('change', renderAllCharts);

        analyzeBtn.addEventListener('click', () => {
            if (trackedData.length < 1) {
                showMessage("請追蹤至少 1 個點以生成數據。建議使用 3 個以上點來進行二次迴歸分析。");
                return;
            }
            trackedData.sort((a, b) => a.time - b.time); 
            calculateDerivedData(trackedData);
            const unit = document.getElementById('unit-select').value;
            let output = `時間 / s\t垂直位置 / m\n`;
            output += "--------------------------------\n";
            for (let i = 0; i < trackedData.length; i++) {
                const p = trackedData[i];
                output += `${p.time.toFixed(3)}\t${p.y_real.toFixed(4)}\n`; 
            }
            document.getElementById('analysis-output').textContent = output;
            renderAllCharts();
        });
    </script>
</body>
</html>
